a. Store this vector of 10 values: foo <- c(7,5,6,1,2,10,8,3,8,2). Then, do the following:
  i. Extract the elements greater than or equal to 5, storing the result as bar.
  ii. Display the vector containing those elements from foo that remain after omitting all elements that are greater than or equal to 5.

b. Use bar from (a)(i) to construct a 2 × 3 matrix called baz, filled in a row-wise fashion. Then, do the following:
  i. Replace any elements that are equal to 8 with the squared value of the element in row 1, column 2 of baz itself.
  ii. Confirm that all values in baz are now less than or equal to 25 AND greater than 4.

c. Create a 3 × 2 × 3 array called qux using the following vector of 18 values: c(10,5,1,4,7,4,3,3,1,3,4,3,1,7,8,3,7,3). Then, do the following:
  i. Identify the dimension-specific index positions of elements that are either 3 OR 4.
  ii. Replace all elements in qux that are less than 3 OR greater than or equal to 7 with the value 100.

d. Return to foo from (a). Use the vector c(F,T) to extract every second value from foo. In Section 4.1.4, you saw that in some situations, you can substitute 0 and 1 for TRUE and FALSE. Can you perform the same extraction from foo using the vector c(0,1)? Why or why not? What does R return in this case?


Solution:
a.

> foo <- c(7,5,6,1,2,10,8,3,8,2)
> bar <- foo[foo >=5]
> bar
[1]  7  5  6 10  8  8
> foo[foo < 5]
[1] 1 2 3 2

b.

> baz <- matrix(bar,2,3,byrow= TRUE)
> baz
     [,1] [,2] [,3]
[1,]    7    5    6
[2,]   10    8    8
> baz[baz == 8] <- baz[1,2]
> baz
     [,1] [,2] [,3]
[1,]    7    5    6
[2,]   10    5    5

> all(baz > 4 | baz <= 25)
[1] TRUE

c.
> qux <- array(c(10,5,1,4,7,4,3,3,1,3,4,3,1,7,8,3,7,3), c(3,2,3))
> qux
, , 1

     [,1] [,2]
[1,]   10    4
[2,]    5    7
[3,]    1    4

, , 2

     [,1] [,2]
[1,]    3    3
[2,]    3    4
[3,]    1    3

, , 3

     [,1] [,2]
[1,]    1    3
[2,]    7    7
[3,]    8    3

> which(qux==3 | qux ==4, arr.ind = T)
      dim1 dim2 dim3
 [1,]    1    2    1
 [2,]    3    2    1
 [3,]    1    1    2
 [4,]    2    1    2
 [5,]    1    2    2
 [6,]    2    2    2
 [7,]    3    2    2
 [8,]    1    2    3
 [9,]    3    2    3
 
 > qux[qux <3 | qux >=7] <- 100
> qux
, , 1

     [,1] [,2]
[1,]  100    4
[2,]    5  100
[3,]  100    4

, , 2

     [,1] [,2]
[1,]    3    3
[2,]    3    4
[3,]  100    3

, , 3

     [,1] [,2]
[1,]  100    3
[2,]  100  100
[3,]  100    3

d.
> foo
 [1]  7  5  6  1  2 10  8  3  8  2
> foo[c(F,T)]
[1]  5  1 10  3  2
> foo[c(0,1)]
[1] 7

No you can't use 0 and 1. In this case, R will interpert as vector 0 and 1. It will return the value at index 0 and 1.
